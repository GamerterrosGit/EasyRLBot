// automatically generated by the FlatBuffers compiler, do not modify

import * as flatbuffers from 'flatbuffers';



export class GameInfo {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):GameInfo {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsGameInfo(bb:flatbuffers.ByteBuffer, obj?:GameInfo):GameInfo {
  return (obj || new GameInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsGameInfo(bb:flatbuffers.ByteBuffer, obj?:GameInfo):GameInfo {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new GameInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

secondsElapsed():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

gameTimeRemaining():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

isOvertime():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

isUnlimitedTime():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * True when cars are allowed to move, and during the pause menu. False during replays.
 */
isRoundActive():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * True when the clock is paused due to kickoff, but false during kickoff countdown. In other words, it is true
 * while cars can move during kickoff. Note that if both players sit still, game clock start and this will become false.
 */
isKickoffPause():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * Turns true after final replay, the moment the 'winner' screen appears. Remains true during next match
 * countdown. Turns false again the moment the 'choose team' screen appears.
 */
isMatchEnded():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

worldGravityZ():number {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Game speed multiplier, 1.0 is regular game speed.
 */
gameSpeed():number {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * Tracks the number of physics frames the game has computed.
 * May increase by more than one across consecutive packets.
 * Data type will roll over after 207 days at 120Hz.
 */
frameNum():number {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

static startGameInfo(builder:flatbuffers.Builder) {
  builder.startObject(10);
}

static addSecondsElapsed(builder:flatbuffers.Builder, secondsElapsed:number) {
  builder.addFieldFloat32(0, secondsElapsed, 0.0);
}

static addGameTimeRemaining(builder:flatbuffers.Builder, gameTimeRemaining:number) {
  builder.addFieldFloat32(1, gameTimeRemaining, 0.0);
}

static addIsOvertime(builder:flatbuffers.Builder, isOvertime:boolean) {
  builder.addFieldInt8(2, +isOvertime, +false);
}

static addIsUnlimitedTime(builder:flatbuffers.Builder, isUnlimitedTime:boolean) {
  builder.addFieldInt8(3, +isUnlimitedTime, +false);
}

static addIsRoundActive(builder:flatbuffers.Builder, isRoundActive:boolean) {
  builder.addFieldInt8(4, +isRoundActive, +false);
}

static addIsKickoffPause(builder:flatbuffers.Builder, isKickoffPause:boolean) {
  builder.addFieldInt8(5, +isKickoffPause, +false);
}

static addIsMatchEnded(builder:flatbuffers.Builder, isMatchEnded:boolean) {
  builder.addFieldInt8(6, +isMatchEnded, +false);
}

static addWorldGravityZ(builder:flatbuffers.Builder, worldGravityZ:number) {
  builder.addFieldFloat32(7, worldGravityZ, 0.0);
}

static addGameSpeed(builder:flatbuffers.Builder, gameSpeed:number) {
  builder.addFieldFloat32(8, gameSpeed, 0.0);
}

static addFrameNum(builder:flatbuffers.Builder, frameNum:number) {
  builder.addFieldInt32(9, frameNum, 0);
}

static endGameInfo(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createGameInfo(builder:flatbuffers.Builder, secondsElapsed:number, gameTimeRemaining:number, isOvertime:boolean, isUnlimitedTime:boolean, isRoundActive:boolean, isKickoffPause:boolean, isMatchEnded:boolean, worldGravityZ:number, gameSpeed:number, frameNum:number):flatbuffers.Offset {
  GameInfo.startGameInfo(builder);
  GameInfo.addSecondsElapsed(builder, secondsElapsed);
  GameInfo.addGameTimeRemaining(builder, gameTimeRemaining);
  GameInfo.addIsOvertime(builder, isOvertime);
  GameInfo.addIsUnlimitedTime(builder, isUnlimitedTime);
  GameInfo.addIsRoundActive(builder, isRoundActive);
  GameInfo.addIsKickoffPause(builder, isKickoffPause);
  GameInfo.addIsMatchEnded(builder, isMatchEnded);
  GameInfo.addWorldGravityZ(builder, worldGravityZ);
  GameInfo.addGameSpeed(builder, gameSpeed);
  GameInfo.addFrameNum(builder, frameNum);
  return GameInfo.endGameInfo(builder);
}

unpack(): GameInfoT {
  return new GameInfoT(
    this.secondsElapsed(),
    this.gameTimeRemaining(),
    this.isOvertime(),
    this.isUnlimitedTime(),
    this.isRoundActive(),
    this.isKickoffPause(),
    this.isMatchEnded(),
    this.worldGravityZ(),
    this.gameSpeed(),
    this.frameNum()
  );
}


unpackTo(_o: GameInfoT): void {
  _o.secondsElapsed = this.secondsElapsed();
  _o.gameTimeRemaining = this.gameTimeRemaining();
  _o.isOvertime = this.isOvertime();
  _o.isUnlimitedTime = this.isUnlimitedTime();
  _o.isRoundActive = this.isRoundActive();
  _o.isKickoffPause = this.isKickoffPause();
  _o.isMatchEnded = this.isMatchEnded();
  _o.worldGravityZ = this.worldGravityZ();
  _o.gameSpeed = this.gameSpeed();
  _o.frameNum = this.frameNum();
}
}

export class GameInfoT {
constructor(
  public secondsElapsed: number = 0.0,
  public gameTimeRemaining: number = 0.0,
  public isOvertime: boolean = false,
  public isUnlimitedTime: boolean = false,
  public isRoundActive: boolean = false,
  public isKickoffPause: boolean = false,
  public isMatchEnded: boolean = false,
  public worldGravityZ: number = 0.0,
  public gameSpeed: number = 0.0,
  public frameNum: number = 0
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  return GameInfo.createGameInfo(builder,
    this.secondsElapsed,
    this.gameTimeRemaining,
    this.isOvertime,
    this.isUnlimitedTime,
    this.isRoundActive,
    this.isKickoffPause,
    this.isMatchEnded,
    this.worldGravityZ,
    this.gameSpeed,
    this.frameNum
  );
}
}
