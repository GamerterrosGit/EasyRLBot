// automatically generated by the FlatBuffers compiler, do not modify

import * as flatbuffers from 'flatbuffers';



export class ControllerState {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):ControllerState {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsControllerState(bb:flatbuffers.ByteBuffer, obj?:ControllerState):ControllerState {
  return (obj || new ControllerState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsControllerState(bb:flatbuffers.ByteBuffer, obj?:ControllerState):ControllerState {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new ControllerState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

/**
 * -1 for full reverse, 1 for full forward
 */
throttle():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * -1 for full left, 1 for full right
 */
steer():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * -1 for nose down, 1 for nose up
 */
pitch():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * -1 for full left, 1 for full right
 */
yaw():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * -1 for roll left, 1 for roll right
 */
roll():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

/**
 * true if you want to press the jump button
 */
jump():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * true if you want to press the boost button
 */
boost():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * true if you want to press the handbrake button
 */
handbrake():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * true if you want to press the 'use item' button, used in rumble etc.
 */
useItem():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

static startControllerState(builder:flatbuffers.Builder) {
  builder.startObject(9);
}

static addThrottle(builder:flatbuffers.Builder, throttle:number) {
  builder.addFieldFloat32(0, throttle, 0.0);
}

static addSteer(builder:flatbuffers.Builder, steer:number) {
  builder.addFieldFloat32(1, steer, 0.0);
}

static addPitch(builder:flatbuffers.Builder, pitch:number) {
  builder.addFieldFloat32(2, pitch, 0.0);
}

static addYaw(builder:flatbuffers.Builder, yaw:number) {
  builder.addFieldFloat32(3, yaw, 0.0);
}

static addRoll(builder:flatbuffers.Builder, roll:number) {
  builder.addFieldFloat32(4, roll, 0.0);
}

static addJump(builder:flatbuffers.Builder, jump:boolean) {
  builder.addFieldInt8(5, +jump, +false);
}

static addBoost(builder:flatbuffers.Builder, boost:boolean) {
  builder.addFieldInt8(6, +boost, +false);
}

static addHandbrake(builder:flatbuffers.Builder, handbrake:boolean) {
  builder.addFieldInt8(7, +handbrake, +false);
}

static addUseItem(builder:flatbuffers.Builder, useItem:boolean) {
  builder.addFieldInt8(8, +useItem, +false);
}

static endControllerState(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createControllerState(builder:flatbuffers.Builder, throttle:number, steer:number, pitch:number, yaw:number, roll:number, jump:boolean, boost:boolean, handbrake:boolean, useItem:boolean):flatbuffers.Offset {
  ControllerState.startControllerState(builder);
  ControllerState.addThrottle(builder, throttle);
  ControllerState.addSteer(builder, steer);
  ControllerState.addPitch(builder, pitch);
  ControllerState.addYaw(builder, yaw);
  ControllerState.addRoll(builder, roll);
  ControllerState.addJump(builder, jump);
  ControllerState.addBoost(builder, boost);
  ControllerState.addHandbrake(builder, handbrake);
  ControllerState.addUseItem(builder, useItem);
  return ControllerState.endControllerState(builder);
}

unpack(): ControllerStateT {
  return new ControllerStateT(
    this.throttle(),
    this.steer(),
    this.pitch(),
    this.yaw(),
    this.roll(),
    this.jump(),
    this.boost(),
    this.handbrake(),
    this.useItem()
  );
}


unpackTo(_o: ControllerStateT): void {
  _o.throttle = this.throttle();
  _o.steer = this.steer();
  _o.pitch = this.pitch();
  _o.yaw = this.yaw();
  _o.roll = this.roll();
  _o.jump = this.jump();
  _o.boost = this.boost();
  _o.handbrake = this.handbrake();
  _o.useItem = this.useItem();
}
}

export class ControllerStateT {
constructor(
  public throttle: number = 0.0,
  public steer: number = 0.0,
  public pitch: number = 0.0,
  public yaw: number = 0.0,
  public roll: number = 0.0,
  public jump: boolean = false,
  public boost: boolean = false,
  public handbrake: boolean = false,
  public useItem: boolean = false
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  return ControllerState.createControllerState(builder,
    this.throttle,
    this.steer,
    this.pitch,
    this.yaw,
    this.roll,
    this.jump,
    this.boost,
    this.handbrake,
    this.useItem
  );
}
}
